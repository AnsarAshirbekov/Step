# # Реализуйте программу, чтобы получить номер недели.
# # Date: 2015, 6, 16

# import datetime

# my_date = input('Введите любую дату в формате "год, месяц, день": ')

# date = datetime.datetime.strptime(my_date, '%Y, %m, %d')

# print(date.isocalendar().week)


# # Реализуйте программу, чтобы найти дату первого понедельника данной недели.
# # Date: 2015, 50

# import datetime
# # Создаем вход для пользователя, где он вводит год и номер недели
# date = input('Введите год и номер недели через пробел: ').split()
# # Первый элемент будет у нас годом
# year = int(date[0])
# # А второй - номером недели
# week_number = int(date[1])
# # Выясняем дату первого дня того года, который ввел пользователь
# year_first_day = datetime.datetime(year, 1, 1)
# # Узнаем номер недели первого дня
# number_of_first_day = year_first_day.isoweekday()
# # Первая неделя может начаться с какого-угодно дня недели и нам нужно знать
# # сколько дней первой недели считать 
# if number_of_first_day == 1: #понедельник
#     days_first_week = 7
# elif number_of_first_day == 2: #вторник
#     days_first_week = 6
# elif number_of_first_day == 3: # среда
#     days_first_week = 5
# elif number_of_first_day == 4: # четверг
#     days_first_week = 4
# elif number_of_first_day == 5: # пятница
#     days_first_week = 3
# elif number_of_first_day == 6: # суббота
#     days_first_week = 2
# elif number_of_first_day == 7: # воскресенье
#     days_first_week = 1
# # Теперь высчитываем количество дней до первого понедельника введенной недели с учетом дней
# # остальных недель
# days_to_first_monday = days_first_week + (week_number - 1) * 7
# # Теперь прибавляем к дате первого дня отрезок времени, равным количеству дней до первого понедельника
# first_monday_date = year_first_day + datetime.timedelta(days=days_to_first_monday)
# # Выводим все это дело в консоль по заданному шаблону
# print(first_monday_date.strftime("пн %d %B %H:%M:%S %Y"))


# # Реализуйте программу, чтобы выбрать все воскресенья определенного года.

# import datetime
# # Создаем вход для ввода года для пользователя
# year = int(input('Введите любой год: '))
# # Узнаем дату первого дня этого года
# day = datetime.date(year, 1, 1)
# # Создаем пустой для воскресений
# sundays = []
# # Создаем цикл который будет перебирать все дни этого года, начиная с первого.
# # Главным условием для него будет то, что год для каждого дня соответствовал нашему году.
# while day.year == year:
#     # И если вдруг индекс дня в неделе будет равен 6, то есть воскресенью, то мы закинем его дату в список
#     # Используем метод .weekday(), который показывает индексы дней в неделе от 0 до 6
#     # Можно также использовать метод .isoweekday(), который показывает номера дней в неделе от 1 до 7
#     if day.weekday() == 6:
#         sundays.append(day)
#     # Увеличиваем дату нашего дня на отрезок времени, равным одним днем, для каждой итерации
#     day = day + datetime.timedelta(days=1)
# # Выводим каждую дату из списка воскресений в консоль
# for sunday in sundays:
#     print(sunday)


# # Реализуйте программу на Python, чтобы добавить год (ы) с заданной датой и отобразить
# # новую дату.

# import datetime

# date = input('Введите дату в формате "год,месяц,день": ')

# years = int(input("""Введите число годов, которые вы хотели бы прибавить или отнять от этой даты
# (если хотите прибавить, напишите просто число, если отнять то "-" и число):  """))

# input_date = datetime.datetime.strptime(date, '%Y,%m,%d')

# if years > 0:
#     result_date = input_date + datetime.timedelta(days = years * 365)
# elif years < 0:
#     result_date = input_date - datetime.timedelta(days = abs(years) * 365)
# else:
#     result_date = input_date

# print(result_date.strftime('%Y-%m-%d'))

# # Это программа не совсем корректно работает, она не учитывает високосные года и думает что каждый год состоит из 365 дней
# # Я даже не знаю, что можно придумать, чтобы учесть и високосные года, но думаю необходимый минимум решения я выполнил :)


# # Реализуйте программу, чтобы узнать время по Гринвичу и местное время.

# from datetime import datetime, timezone

# greenwich_time = datetime.now(timezone.utc)

# local_time = datetime.now()

# print(greenwich_time)

# print(local_time)


# # Реализуйте программу, для вычисления количества дней между двумя датами

# import datetime

# date1 = input('Введите первую дату в формате "год-месяц-день": ')
# date2 = input('Введите вторую дату в формате "год-месяц-день": ')

# date1_format = datetime.datetime.strptime(date1, '%Y-%m-%d')
# date2_format = datetime.datetime.strptime(date2, '%Y-%m-%d')

# difference = abs(date1_format - date2_format)
# # Выводим в консоль переменную difference класса timedelta, но только ее дни
# print(difference.days)


# # Реализуйте программу, для преобразования двух разностей дат в дни, часы, минуты и
# # секунды

# # Двух разностей дат или разности двух дат? Будем считать что второе)

# import datetime

# date1 = input('Введите первую дату в формате "год-месяц-день": ')
# date2 = input('Введите вторую дату в формате "год-месяц-день": ')

# date1_format = datetime.datetime.strptime(date1, '%Y-%m-%d')
# date2_format = datetime.datetime.strptime(date2, '%Y-%m-%d')

# difference = abs(date1_format - date2_format)
# # Выводим в консоль все что может нам выдать класс timedelta, а это и есть дни, часы, минуты и секунды
# print(difference)


# # Реализуйте программу на Python, для создания HTML-календаря с данными за
# # определенный год и месяц.

# # Используем модуль calendar для решения этой задачи
# # Этот модуль предоставляет различные функции для работы с календарями,
# # которые могут определять дни недели, количество дней в месяце, форматирование календаря и пр.
# import calendar

# year = int(input('Введите любой год: '))
# month = int(input('Введите номер любого месяца (1 до 12): '))

# # Создаем переменную для передачи в нее данных о календаре
# my_calendar = calendar.HTMLCalendar().formatmonth(year, month)
# # Модуль calendar содержит в себе в функцию HTMLCalendar, которая создает объект календаря,
# # специально предназначенного для форматирования календаря в HTML
# # Функция же в свою очередь содержит метод .formatmonth, который форматирует календарь для 
# # указанного месяца и года в виде HTML-строки.

# # Полученную HTML-строку можно просто вывести в консоль
# # print(my_calendar)
# # Но наглядней было б создать html-файл, в который мы запишем полученный код  
# with open("calendar.html", "w") as file:
#     file.write(my_calendar)
# # Здесь у нас создастся отдельный файл с HTML-кодом, открыв через браузер который мы увидим сам календарь


# # Дан текстовый файл. Необходимо создать новый файл убрав из него все неприемлемые
# # слова. Список неприемлемых слов находится в другом файле.

# # У нас заготовлен и лежит в этой же папке тектовый документ с любым текстом
# # Также у нас заготовлен текстовый документ с предлогами в этой же папке
# # Нужно удалить из первого текста все предлоги и сохранить в новый файл

# # Для начала прочитаем текстовый документ с предлогами
# with open('C:\\Users\\User\\Desktop\\Step\\Python\\Completed Homeworks Python\\lesson 12\\Предлоги.txt', 'r', encoding='utf-8') as file:
#     prepositions = file.readlines()
# # Теперь прочитаем любой текст
# with open('C:\\Users\\User\\Desktop\\Step\\Python\\Completed Homeworks Python\\lesson 12\\Любой текст.txt', 'r', encoding='utf-8') as file:
#     text = file.readlines()
# # Метод .readlines вернул нам список с одним элементом строкой
# # Нам нужно сделать список, где каждое слово это отдельный элемент
# for preposition in prepositions:
#     prepositions = preposition.split()

# for word in text:
#     text = word.split()

# # Теперь создадим пустой список
# result = []
# # В этот список мы будем закидывать из любого текста те слова, которые НЕ находятся в предлогах
# for word in text:
#     if word not in prepositions:
#         result.append(word)

# # Превратим все наши элементы списка в одну большую строку
# result_text = ' '.join(result)

# # Создадим новый текстовый документ, в которую запишем нашу строку
# with open('Результат.txt', 'w') as file:
#     file.write(result_text)


# # Написать программу транслитерации с русского на английский и наоборот. Данные для
# # транслитерации берутся из файла и записываются в другой файл. Направление перевода
# # определяется через меню пользователя

# # Транслитерация - побуквенная передача отдельных слов и текстов одного языка буквами другого
# # Для начала создадим две функции, одна из которых будет принимать текст на русском языке
# # и транслитерировать его английскими буквами, а вторая принимать текст на английском языке
# # и транслитерировать его русскими буквами
# def transliterate_rus_to_eng(text):
#     # Создаем словарь, где ключи это русские буквы, а значения - их транслитерация английскими буквами
#     translit_dict = {
#         'а': 'a', 'б': 'b', 'в': 'v', 'г': 'g', 'д': 'd', 'е': 'e', 'ё': 'yo',
#         'ж': 'zh', 'з': 'z', 'и': 'i', 'й': 'y', 'к': 'k', 'л': 'l', 'м': 'm',
#         'н': 'n', 'о': 'o', 'п': 'p', 'р': 'r', 'с': 's', 'т': 't', 'у': 'u',
#         'ф': 'f', 'х': 'h', 'ц': 'ts', 'ч': 'ch', 'ш': 'sh', 'щ': 'sch',
#         'ъ': '', 'ы': 'y', 'ь': '', 'э': 'e', 'ю': 'yu', 'я': 'ya',
#         'А': 'A', 'Б': 'B', 'В': 'V', 'Г': 'G', 'Д': 'D', 'Е': 'E', 'Ё': 'Yo',
#         'Ж': 'Zh', 'З': 'Z', 'И': 'I', 'Й': 'Y', 'К': 'K', 'Л': 'L', 'М': 'M',
#         'Н': 'N', 'О': 'O', 'П': 'P', 'Р': 'R', 'С': 'S', 'Т': 'T', 'У': 'U',
#         'Ф': 'F', 'Х': 'H', 'Ц': 'Ts', 'Ч': 'Ch', 'Ш': 'Sh', 'Щ': 'Sch',
#         'Ъ': '', 'Ы': 'Y', 'Ь': '', 'Э': 'E', 'Ю': 'Yu', 'Я': 'Ya'
#     }
#     # Теперь создаем генератор списка, элементы которого будут браться из значений по ключам, которые
#     # в свою очередь будут соответстовать буквам из принимаемого текста
#     # Допустим есть текст "Мыло", генератор списка заходит в словарь, находит ключи: М, ы, л, о. Этим 
#     # ключам соответствуют значения: M, y, l, o. Генератор создает словарь из элементов [M, y, l, o].
#     # Внутри get пишется (char, char), то есть 2 раза, для того, чтобы если вдруг внутри текста найдется
#     # такой элемент, который не будет соответствовать ни одному из ключей словаря, то генератор запишет в 
#     # список само название ключа, если этого не делать, то запишется None
#     # Допустим в тексте есть знаки препинания, цифры и пробелы, их нет в словаре, значит генератор просто
#     # внесет их в список без изменений.
#     # После этого нам надо собрать из списка транслитерированных букв цельное предложение. Для этого каждый 
#     # элемент присоединяем друг к другу без изменений и получится строка
#     transliterated_text = ''.join(translit_dict.get(char, char) for char in text)
#     return transliterated_text

# def transliterate_eng_to_rus(text):
#     translit_dict = {
#         'a': 'а', 'b': 'б', 'c': 'ц', 'd': 'д', 'e': 'е', 'f': 'ф', 'g': 'г',
#         'h': 'х', 'i': 'и', 'j': 'й', 'k': 'к', 'l': 'л', 'm': 'м', 'n': 'н',
#         'o': 'о', 'p': 'п', 'q': 'к', 'r': 'р', 's': 'с', 't': 'т', 'u': 'у',
#         'v': 'в', 'w': 'в', 'x': 'кс', 'y': 'ы', 'z': 'з',
#         'A': 'А', 'B': 'Б', 'C': 'Ц', 'D': 'Д', 'E': 'Е', 'F': 'Ф', 'G': 'Г',
#         'H': 'Х', 'I': 'И', 'J': 'Й', 'K': 'К', 'L': 'Л', 'M': 'М', 'N': 'Н',
#         'O': 'О', 'P': 'П', 'Q': 'К', 'R': 'Р', 'S': 'С', 'T': 'Т', 'U': 'У',
#         'V': 'В', 'W': 'В', 'X': 'КС', 'Y': 'Ы', 'Z': 'З'
#     }
#     transliterated_text = ''.join(translit_dict.get(char, char) for char in text)
#     return transliterated_text

# print("1. Транслитерация с русского на английский")
# print("2. Транслитерация с английского на русский")
# print("3. Выйти из программы")
        
# choice = input("Выберите направление транслитерации (1, 2, или 3): ")
        
# if choice == '1':
#     input_file = input("Введите имя файла с русским текстом: ")
#     output_file = input("Введите имя файла для сохранения транслитерированного текста: ")
#     try:
#         with open(input_file, 'r', encoding='utf-8') as file:
#             russian_text = file.read()
#             transliterated_text = transliterate_rus_to_eng(russian_text)
#         with open(output_file, 'w', encoding='utf-8') as file:
#                 file.write(transliterated_text)
#         print("Текст успешно транслитерирован.")
#     except FileNotFoundError:
#         print("Файл не найден.")
        
# elif choice == '2':
#     input_file = input("Введите имя файла с английским текстом: ")
#     output_file = input("Введите имя файла для сохранения транслитерированного текста: ")
#     try:
#         with open(input_file, 'r', encoding='utf-8') as file:
#             english_text = file.read()
#             transliterated_text = transliterate_eng_to_rus(english_text)
#         with open(output_file, 'w', encoding='utf-8') as file:
#             file.write(transliterated_text)
#         print("Текст успешно транслитерирован.")
#     except FileNotFoundError:
#         print("Файл не найден.")
        
# elif choice == '3':
#     print("Программа завершена.")
        
# else:
#     print("Некорректный выбор. Пожалуйста, введите 1, 2 или 3.")


# # Пользователь с клавиатуры вводит названия файлов, до тех пор, пока он не введет слово
# # quit. После завершения ввода программа должна объединить содержимое всех перечисленных
# # пользователем файлов в один.

# # Создаем пустой список для содержания контента внутри файлов
# content = []
# # Запускаем бесконечный цикл..
# while True:
#     # в котором пользователь будет вводить названия файлов
#     filename = input('Введите название файла: ')
#     # Условием для завершения бесконечного цикла будет то, что название файла вдруг станет quit
#     if filename == 'quit':
#         break
#     # Но пока это условие не выполнилось, пользователь будет вводить названия файлов до бесконечности
#     # Здесь может выйти так, что файла с названием, введенным пользователем, нет и тогда выйдет ошибка и код завершится
#     # Чтобы этого не произошло, нужно учесть такую ошибку
#     # Пускай программа попробует открыть файл с названием, прочитать его содержимое, и записать содержимое в наш список
#     try:
#         with open(filename, 'r', encoding='utf-8') as file:
#             content.append(file.read())
#     # Но если вдруг файла с таким названием нет..
#     except FileNotFoundError:
#         # то пользователю выведется следующее:
#         print(f'Файл {filename} не найден. Попробуйте еще раз.')

# # Конвертируем элементы нашего списка в строку таким образом, чтобы каждый элемент был на отдельной строке
# merged_content = '\n'.join(content)
# # Создаем новый файл и записываем в него нашу строку
# with open('Объединенный контент.txt', 'w', encoding='utf-8') as file:
#     file.write(merged_content)


# # Пользователь с клавиатуры вводит названия файлов, до тех пор, пока он не введет слово
# # quit. После завершения ввода программа должна записать в итоговый файл символы, которые
# # есть во всех перечисленных файлах (символы должны быть в каждом файле).

# # Создаем пустой список для содержания контента внутри файлов
# content = []
# # Создаем пустой множество, куда мы будем записывать общие символы из контента файлов
# common_symbols = set()
# # Запускаем бесконечный цикл
# while True:
#     filename = input('Введите название файла: ')
#     if filename == 'quit':
#         break
#     try:
#         with open(filename, 'r', encoding='utf-8') as file:
#             # Здесь мы считываем с каждого файла содержимое и сразу конвертируем его во множество
#             file_content = set(file.read())
#             # и каждое такое множество добавляем в список контента и у нас будет список множеств
#             content.append(file_content)
#     except FileNotFoundError:
#         print(f'Файл {filename} не найден. Попробуйте еще раз.')

# if content: # Здесь проверяется есть ли хотя бы одно множество в списке множеств, и если есть то значит условие истино,
#             # и выполняется действие внутри этого условия
#     # Здесь мы с помощью * распаковываем наш список множеств и сразу применяем к ним метод .intersection, который находит
#     # пересечения этих множеств и возвращает их в виде множества
#     common_symbols = set.intersection(*content)
#     # Создаем новый файл, куда мы записываем наше множество общих символов, конвертированное в строку
#     with open('Общие символы.txt', 'w', encoding='utf-8') as file:
#         file.write(' '.join(common_symbols))
# else: # если условие не истино, то есть когда не было прочитано ни одного файла, если пользователь сразу ввел quit,
#     # то ему выведется следующее:
#     print('Ни одного файла не было отработано: ')


# # В текущей папке лежат две другие папки: video и sub. Создайте новую папку watch_me
# # и переложите туда содержимое указанных папок (сами папки класть не надо).

# # Здесь мы будем пользоваться модулем os который включает  в себя создание, переименование,
# # перемещение, удаление файлов и папок, а также получение списка всех файлов и каталогов и
# # многое другое.
# import os

# # Узнаем текущую директорию (путь), то есть где мы сейчас находимся
# current_dir = os.getcwd()

# # Как сказано в условии задачи, в текущей папке лежат две папки: video и sub
# # Мы заранее уже создали их и положили в них некоторое содержимое
# # Узнаем директории этих папок путем объединения путей текущей директории с непосредственно 
# # с этими папками
# video_dir = os.path.join(current_dir, 'video')

# sub_dir = os.path.join(current_dir, 'sub')

# # Теперь создадим папку watch_me куда мы переместим содержимое папок video и sub
# # Но просто написать 
# # os.mkdir('watch_me')
# # будет не совсем правильно, потому если в нашей текущей директории уже есть папка с таким названием,
# # то выйдет ошибка
# # Лучше всего сначала узнать, есть ли здесь уже папка с таким названием
# if not os.path.exists('watch_me'):
#     # если же нет, то есть True, то создается папка 
#     os.makedirs('watch_me') # Здесь предпочтительней использовать .makedirs а не .mkdir, потому что второй
#                             # при создании папки не учитывает промежуточные директории, если не они не 
#                             # существуют и может выдать ошибку. .makedirs же если не существует промежуточных 
#                             # директорий - создает их, что делает его более гибким
# else:
#     print(False)

# # Теперь узнаем директорию папки watch_me
# watch_me_dir = os.path.join(current_dir, 'watch_me')

# # Для перемещения файлов с одной папки в другую нам необходим модуль shutil, который содержит в себе функцию .move
# import shutil

# # Теперь нам нужно найти файлы в папках video и sub
# # но в этих папках могут быть и другие папки, и нам нужно их все проверить
# for folder in [video_dir, sub_dir]: # оборачиваем наши директории в список, чтобы цикл по ним прошелся
#     # во внутренних папках узнаем имена файлов для каждого файла с помощью функции .listdir, которая возращает имена
#     # каждого файла в папке
#     for item in os.listdir(folder):
#         # выясняем директории этих файлов путем объединения директорий папок в которых они находятся и самих файлов 
#         item_dir = os.path.join(folder, item)
#         # и если по директории файл является файлом, а не папкой
#         if os.path.isfile(item_dir):
#             # то перетаскиваем его из своей директории в директорию папки watch_me
#             shutil.move(item_dir, watch_me_dir)


# # В текущей папке лежат файлы типа Nina_Stoletova.jpg, Misha_Perelman.jpg и т.п.
# # Переименуйте их переставив имя и фамилию местами.

# import os

# # Получаем текущий рабочий каталог (директорию)
# current_dir = os.getcwd()

# # Получаем список файлов в текущем каталоге
# files = os.listdir(current_dir)

# # Проходимся по каждому файлу
# for file_name in files:
#     # Здесь каждый файл имеет в названии расширение, чтобы его исключить, нужно разделить название на базовое имя и расширение
#     base_name, extension = os.path.splitext(file_name)
#     # Разбиваем имя файла на части по разделителю "_". Если же названия файлов не содержат "_", то цикл не будет их трогать
#     parts = base_name.split("_")
#     # Проверяем, что в имени файла есть как минимум две части (предполагаем, что первая - имя, вторая - фамилия)
#     if len(parts) >= 2:
#         # Переставляем имя и фамилию местами и не забываем про расширение
#         new_name = f"{parts[1]}_{parts[0]}{extension}"
#         # Переименовываем файл
#         os.rename(os.path.join(current_dir, file_name), os.path.join(current_dir, new_name))


# # В текущей папке лежит файл list.tsv, в котором с новой строки написаны имена
# # некоторых других файлов этой папки. Создайте папку list и переложите в неё данные файлы.

# import os
# # import shutil

# # Получаем текущий рабочий каталог
# current_dir = os.getcwd()

# # Создаем новую папку "list"
# list_dir = os.path.join(current_dir, 'list')
# if not os.path.exists(list_dir):
#     os.makedirs(list_dir)

# # Путь к файлу list.tsv
# list_file = os.path.join(current_dir, 'list.tsv')

# # Проверяем, существует ли файл list.tsv
# if os.path.exists(list_file):
#     # Читаем содержимое файла list.tsv
#     with open(list_file, 'r', encoding='utf=8') as file:
#         # Читаем имена файлов из list.tsv и удаляем возможные символы новой строки
#         file_names = [line.strip() for line in file.readlines()]

#     # Перемещаем файлы в папку "list"
#     for file_name in file_names:
#         # Проверяем, существует ли файл с именем, указанным в list.tsv
#         if os.path.exists(os.path.join(current_dir, file_name)):
#             # Перемещаем файл в папку "list"
#             # Здесь мы перемещаем файл с помощью переименования директорий
#             # То есть файл находился в какой-то одной директории и мы его перетащили в директорию с другим названием
#             os.rename(os.path.join(current_dir, file_name), os.path.join(list_dir, file_name))
#             # Здесь также можно использовать функцию .move из модуля shutil, он более продвинутый и сложный, может
#             # перемещать файлы между разными файловыми системами, например между дисками
#             # shutil.move(os.path.join(current_dir, file_name), os.path.join(list_dir, file_name))
#             # Но конкретно здесь лучше использовать .rename из os, потому что мы находимся в одной файловой системе,
#             # перемещаем текстовые файлы маленького размера, эта функция будет работать быстрее


# Дан текстовый файл. Удалить из него последнюю строку. Результат записать в другой файл

# with open('Объединенный контент.txt', 'r', encoding='utf=8') as file:
#     lines = file.readlines()

# # last_line = lines[-1]
# # lines.remove(last_line)

# # last_line = lines.pop()

# # Используем срез. Список будет без последнего элемента
# lines = lines[:-1]

# with open('Урезаный контент.txt', 'w', encoding='utf=8') as file:
#     file.write(''.join(lines))